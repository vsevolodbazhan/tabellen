<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>tabellen.tasks API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tabellen.tasks</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Any, Dict

from requests import Response
from requests import post as post_request

from .config import celery

__all__ = [&#34;Response&#34;, &#34;post_request&#34;, &#34;revoke_task&#34;]


@celery.task
def send_request(url: str, payload: Dict[str, Any]) -&gt; Response:
    &#34;&#34;&#34;A Celery task that sends a POST request to the given URL.

    Args:
        url (str): URL to send request to.
        payload (Dict[str, Any]): Request payload. Must be JSON-serializable.

    Returns:
        Response: Received response.
    &#34;&#34;&#34;

    return post_request(url, json=payload)


def revoke_task(task_id: str) -&gt; None:
    &#34;&#34;&#34;Cancel a planned task.

    Args:
        task_id (str): Task ID.

    Returns:
        None
    &#34;&#34;&#34;

    celery.control.revoke(task_id)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tabellen.tasks.post_request"><code class="name flex">
<span>def <span class="ident">post_request</span></span>(<span>url, data=None, json=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a POST request.</p>
<p>:param url: URL for the new :class:<code>Request</code> object.
:param data: (optional) Dictionary, list of tuples, bytes, or file-like
object to send in the body of the :class:<code>Request</code>.
:param json: (optional) json data to send in the body of the :class:<code>Request</code>.
:param **kwargs: Optional arguments that <code>request</code> takes.
:return: :class:<code>Response &lt;Response&gt;</code> object
:rtype: requests.Response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post(url, data=None, json=None, **kwargs):
    r&#34;&#34;&#34;Sends a POST request.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, list of tuples, bytes, or file-like
        object to send in the body of the :class:`Request`.
    :param json: (optional) json data to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response &lt;Response&gt;` object
    :rtype: requests.Response
    &#34;&#34;&#34;

    return request(&#39;post&#39;, url, data=data, json=json, **kwargs)</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.revoke_task"><code class="name flex">
<span>def <span class="ident">revoke_task</span></span>(<span>task_id: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel a planned task.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Task ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revoke_task(task_id: str) -&gt; None:
    &#34;&#34;&#34;Cancel a planned task.

    Args:
        task_id (str): Task ID.

    Returns:
        None
    &#34;&#34;&#34;

    celery.control.revoke(task_id)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tabellen.tasks.Response"><code class="flex name class">
<span>class <span class="ident">Response</span></span>
</code></dt>
<dd>
<div class="desc"><p>The :class:<code>Response &lt;Response&gt;</code> object, which contains a
server's response to an HTTP request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Response(object):
    &#34;&#34;&#34;The :class:`Response &lt;Response&gt;` object, which contains a
    server&#39;s response to an HTTP request.
    &#34;&#34;&#34;

    __attrs__ = [
        &#39;_content&#39;, &#39;status_code&#39;, &#39;headers&#39;, &#39;url&#39;, &#39;history&#39;,
        &#39;encoding&#39;, &#39;reason&#39;, &#39;cookies&#39;, &#39;elapsed&#39;, &#39;request&#39;
    ]

    def __init__(self):
        self._content = False
        self._content_consumed = False
        self._next = None

        #: Integer Code of responded HTTP Status, e.g. 404 or 200.
        self.status_code = None

        #: Case-insensitive Dictionary of Response Headers.
        #: For example, ``headers[&#39;content-encoding&#39;]`` will return the
        #: value of a ``&#39;Content-Encoding&#39;`` response header.
        self.headers = CaseInsensitiveDict()

        #: File-like object representation of response (for advanced usage).
        #: Use of ``raw`` requires that ``stream=True`` be set on the request.
        #: This requirement does not apply for use internally to Requests.
        self.raw = None

        #: Final URL location of Response.
        self.url = None

        #: Encoding to decode with when accessing r.text.
        self.encoding = None

        #: A list of :class:`Response &lt;Response&gt;` objects from
        #: the history of the Request. Any redirect responses will end
        #: up here. The list is sorted from the oldest to the most recent request.
        self.history = []

        #: Textual reason of responded HTTP Status, e.g. &#34;Not Found&#34; or &#34;OK&#34;.
        self.reason = None

        #: A CookieJar of Cookies the server sent back.
        self.cookies = cookiejar_from_dict({})

        #: The amount of time elapsed between sending the request
        #: and the arrival of the response (as a timedelta).
        #: This property specifically measures the time taken between sending
        #: the first byte of the request and finishing parsing the headers. It
        #: is therefore unaffected by consuming the response content or the
        #: value of the ``stream`` keyword argument.
        self.elapsed = datetime.timedelta(0)

        #: The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to which this
        #: is a response.
        self.request = None

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def __getstate__(self):
        # Consume everything; accessing the content attribute makes
        # sure the content has been fully read.
        if not self._content_consumed:
            self.content

        return {attr: getattr(self, attr, None) for attr in self.__attrs__}

    def __setstate__(self, state):
        for name, value in state.items():
            setattr(self, name, value)

        # pickled objects do not have .raw
        setattr(self, &#39;_content_consumed&#39;, True)
        setattr(self, &#39;raw&#39;, None)

    def __repr__(self):
        return &#39;&lt;Response [%s]&gt;&#39; % (self.status_code)

    def __bool__(self):
        &#34;&#34;&#34;Returns True if :attr:`status_code` is less than 400.

        This attribute checks if the status code of the response is between
        400 and 600 to see if there was a client error or a server error. If
        the status code, is between 200 and 400, this will return True. This
        is **not** a check to see if the response code is ``200 OK``.
        &#34;&#34;&#34;
        return self.ok

    def __nonzero__(self):
        &#34;&#34;&#34;Returns True if :attr:`status_code` is less than 400.

        This attribute checks if the status code of the response is between
        400 and 600 to see if there was a client error or a server error. If
        the status code, is between 200 and 400, this will return True. This
        is **not** a check to see if the response code is ``200 OK``.
        &#34;&#34;&#34;
        return self.ok

    def __iter__(self):
        &#34;&#34;&#34;Allows you to use a response as an iterator.&#34;&#34;&#34;
        return self.iter_content(128)

    @property
    def ok(self):
        &#34;&#34;&#34;Returns True if :attr:`status_code` is less than 400, False if not.

        This attribute checks if the status code of the response is between
        400 and 600 to see if there was a client error or a server error. If
        the status code is between 200 and 400, this will return True. This
        is **not** a check to see if the response code is ``200 OK``.
        &#34;&#34;&#34;
        try:
            self.raise_for_status()
        except HTTPError:
            return False
        return True

    @property
    def is_redirect(self):
        &#34;&#34;&#34;True if this Response is a well-formed HTTP redirect that could have
        been processed automatically (by :meth:`Session.resolve_redirects`).
        &#34;&#34;&#34;
        return (&#39;location&#39; in self.headers and self.status_code in REDIRECT_STATI)

    @property
    def is_permanent_redirect(self):
        &#34;&#34;&#34;True if this Response one of the permanent versions of redirect.&#34;&#34;&#34;
        return (&#39;location&#39; in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))

    @property
    def next(self):
        &#34;&#34;&#34;Returns a PreparedRequest for the next request in a redirect chain, if there is one.&#34;&#34;&#34;
        return self._next

    @property
    def apparent_encoding(self):
        &#34;&#34;&#34;The apparent encoding, provided by the chardet library.&#34;&#34;&#34;
        return chardet.detect(self.content)[&#39;encoding&#39;]

    def iter_content(self, chunk_size=1, decode_unicode=False):
        &#34;&#34;&#34;Iterates over the response data.  When stream=True is set on the
        request, this avoids reading the content at once into memory for
        large responses.  The chunk size is the number of bytes it should
        read into memory.  This is not necessarily the length of each item
        returned as decoding can take place.

        chunk_size must be of type int or None. A value of None will
        function differently depending on the value of `stream`.
        stream=True will read data as it arrives in whatever size the
        chunks are received. If stream=False, data is returned as
        a single chunk.

        If decode_unicode is True, content will be decoded using the best
        available encoding based on the response.
        &#34;&#34;&#34;

        def generate():
            # Special case for urllib3.
            if hasattr(self.raw, &#39;stream&#39;):
                try:
                    for chunk in self.raw.stream(chunk_size, decode_content=True):
                        yield chunk
                except ProtocolError as e:
                    raise ChunkedEncodingError(e)
                except DecodeError as e:
                    raise ContentDecodingError(e)
                except ReadTimeoutError as e:
                    raise ConnectionError(e)
            else:
                # Standard file-like object.
                while True:
                    chunk = self.raw.read(chunk_size)
                    if not chunk:
                        break
                    yield chunk

            self._content_consumed = True

        if self._content_consumed and isinstance(self._content, bool):
            raise StreamConsumedError()
        elif chunk_size is not None and not isinstance(chunk_size, int):
            raise TypeError(&#34;chunk_size must be an int, it is instead a %s.&#34; % type(chunk_size))
        # simulate reading small chunks of the content
        reused_chunks = iter_slices(self._content, chunk_size)

        stream_chunks = generate()

        chunks = reused_chunks if self._content_consumed else stream_chunks

        if decode_unicode:
            chunks = stream_decode_response_unicode(chunks, self)

        return chunks

    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):
        &#34;&#34;&#34;Iterates over the response data, one line at a time.  When
        stream=True is set on the request, this avoids reading the
        content at once into memory for large responses.

        .. note:: This method is not reentrant safe.
        &#34;&#34;&#34;

        pending = None

        for chunk in self.iter_content(chunk_size=chunk_size, decode_unicode=decode_unicode):

            if pending is not None:
                chunk = pending + chunk

            if delimiter:
                lines = chunk.split(delimiter)
            else:
                lines = chunk.splitlines()

            if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:
                pending = lines.pop()
            else:
                pending = None

            for line in lines:
                yield line

        if pending is not None:
            yield pending

    @property
    def content(self):
        &#34;&#34;&#34;Content of the response, in bytes.&#34;&#34;&#34;

        if self._content is False:
            # Read the contents.
            if self._content_consumed:
                raise RuntimeError(
                    &#39;The content for this response was already consumed&#39;)

            if self.status_code == 0 or self.raw is None:
                self._content = None
            else:
                self._content = b&#39;&#39;.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b&#39;&#39;

        self._content_consumed = True
        # don&#39;t need to release the connection; that&#39;s been handled by urllib3
        # since we exhausted the data.
        return self._content

    @property
    def text(self):
        &#34;&#34;&#34;Content of the response, in unicode.

        If Response.encoding is None, encoding will be guessed using
        ``chardet``.

        The encoding of the response content is determined based solely on HTTP
        headers, following RFC 2616 to the letter. If you can take advantage of
        non-HTTP knowledge to make a better guess at the encoding, you should
        set ``r.encoding`` appropriately before accessing this property.
        &#34;&#34;&#34;

        # Try charset from content-type
        content = None
        encoding = self.encoding

        if not self.content:
            return str(&#39;&#39;)

        # Fallback to auto-detected encoding.
        if self.encoding is None:
            encoding = self.apparent_encoding

        # Decode unicode from given encoding.
        try:
            content = str(self.content, encoding, errors=&#39;replace&#39;)
        except (LookupError, TypeError):
            # A LookupError is raised if the encoding was not found which could
            # indicate a misspelling or similar mistake.
            #
            # A TypeError can be raised if encoding is None
            #
            # So we try blindly encoding.
            content = str(self.content, errors=&#39;replace&#39;)

        return content

    def json(self, **kwargs):
        r&#34;&#34;&#34;Returns the json-encoded content of a response, if any.

        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises ValueError: If the response body does not contain valid json.
        &#34;&#34;&#34;

        if not self.encoding and self.content and len(self.content) &gt; 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using chardet to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(
                        self.content.decode(encoding), **kwargs
                    )
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it&#39;s not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn&#39;t bother to tell us what codec *was*
                    # used.
                    pass
        return complexjson.loads(self.text, **kwargs)

    @property
    def links(self):
        &#34;&#34;&#34;Returns the parsed header links of the response, if any.&#34;&#34;&#34;

        header = self.headers.get(&#39;link&#39;)

        # l = MultiDict()
        l = {}

        if header:
            links = parse_header_links(header)

            for link in links:
                key = link.get(&#39;rel&#39;) or link.get(&#39;url&#39;)
                l[key] = link

        return l

    def raise_for_status(self):
        &#34;&#34;&#34;Raises :class:`HTTPError`, if one occurred.&#34;&#34;&#34;

        http_error_msg = &#39;&#39;
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn&#39;t utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode(&#39;utf-8&#39;)
            except UnicodeDecodeError:
                reason = self.reason.decode(&#39;iso-8859-1&#39;)
        else:
            reason = self.reason

        if 400 &lt;= self.status_code &lt; 500:
            http_error_msg = u&#39;%s Client Error: %s for url: %s&#39; % (self.status_code, reason, self.url)

        elif 500 &lt;= self.status_code &lt; 600:
            http_error_msg = u&#39;%s Server Error: %s for url: %s&#39; % (self.status_code, reason, self.url)

        if http_error_msg:
            raise HTTPError(http_error_msg, response=self)

    def close(self):
        &#34;&#34;&#34;Releases the connection back to the pool. Once this method has been
        called the underlying ``raw`` object must not be accessed again.

        *Note: Should not normally need to be called explicitly.*
        &#34;&#34;&#34;
        if not self._content_consumed:
            self.raw.close()

        release_conn = getattr(self.raw, &#39;release_conn&#39;, None)
        if release_conn is not None:
            release_conn()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tabellen.tasks.Response.apparent_encoding"><code class="name">var <span class="ident">apparent_encoding</span></code></dt>
<dd>
<div class="desc"><p>The apparent encoding, provided by the chardet library.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def apparent_encoding(self):
    &#34;&#34;&#34;The apparent encoding, provided by the chardet library.&#34;&#34;&#34;
    return chardet.detect(self.content)[&#39;encoding&#39;]</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>Content of the response, in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content(self):
    &#34;&#34;&#34;Content of the response, in bytes.&#34;&#34;&#34;

    if self._content is False:
        # Read the contents.
        if self._content_consumed:
            raise RuntimeError(
                &#39;The content for this response was already consumed&#39;)

        if self.status_code == 0 or self.raw is None:
            self._content = None
        else:
            self._content = b&#39;&#39;.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b&#39;&#39;

    self._content_consumed = True
    # don&#39;t need to release the connection; that&#39;s been handled by urllib3
    # since we exhausted the data.
    return self._content</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.is_permanent_redirect"><code class="name">var <span class="ident">is_permanent_redirect</span></code></dt>
<dd>
<div class="desc"><p>True if this Response one of the permanent versions of redirect.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_permanent_redirect(self):
    &#34;&#34;&#34;True if this Response one of the permanent versions of redirect.&#34;&#34;&#34;
    return (&#39;location&#39; in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.is_redirect"><code class="name">var <span class="ident">is_redirect</span></code></dt>
<dd>
<div class="desc"><p>True if this Response is a well-formed HTTP redirect that could have
been processed automatically (by :meth:<code>Session.resolve_redirects</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_redirect(self):
    &#34;&#34;&#34;True if this Response is a well-formed HTTP redirect that could have
    been processed automatically (by :meth:`Session.resolve_redirects`).
    &#34;&#34;&#34;
    return (&#39;location&#39; in self.headers and self.status_code in REDIRECT_STATI)</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.links"><code class="name">var <span class="ident">links</span></code></dt>
<dd>
<div class="desc"><p>Returns the parsed header links of the response, if any.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def links(self):
    &#34;&#34;&#34;Returns the parsed header links of the response, if any.&#34;&#34;&#34;

    header = self.headers.get(&#39;link&#39;)

    # l = MultiDict()
    l = {}

    if header:
        links = parse_header_links(header)

        for link in links:
            key = link.get(&#39;rel&#39;) or link.get(&#39;url&#39;)
            l[key] = link

    return l</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.next"><code class="name">var <span class="ident">next</span></code></dt>
<dd>
<div class="desc"><p>Returns a PreparedRequest for the next request in a redirect chain, if there is one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def next(self):
    &#34;&#34;&#34;Returns a PreparedRequest for the next request in a redirect chain, if there is one.&#34;&#34;&#34;
    return self._next</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.ok"><code class="name">var <span class="ident">ok</span></code></dt>
<dd>
<div class="desc"><p>Returns True if :attr:<code>status_code</code> is less than 400, False if not.</p>
<p>This attribute checks if the status code of the response is between
400 and 600 to see if there was a client error or a server error. If
the status code is between 200 and 400, this will return True. This
is <strong>not</strong> a check to see if the response code is <code>200 OK</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ok(self):
    &#34;&#34;&#34;Returns True if :attr:`status_code` is less than 400, False if not.

    This attribute checks if the status code of the response is between
    400 and 600 to see if there was a client error or a server error. If
    the status code is between 200 and 400, this will return True. This
    is **not** a check to see if the response code is ``200 OK``.
    &#34;&#34;&#34;
    try:
        self.raise_for_status()
    except HTTPError:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<div class="desc"><p>Content of the response, in unicode.</p>
<p>If Response.encoding is None, encoding will be guessed using
<code>chardet</code>.</p>
<p>The encoding of the response content is determined based solely on HTTP
headers, following RFC 2616 to the letter. If you can take advantage of
non-HTTP knowledge to make a better guess at the encoding, you should
set <code>r.encoding</code> appropriately before accessing this property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text(self):
    &#34;&#34;&#34;Content of the response, in unicode.

    If Response.encoding is None, encoding will be guessed using
    ``chardet``.

    The encoding of the response content is determined based solely on HTTP
    headers, following RFC 2616 to the letter. If you can take advantage of
    non-HTTP knowledge to make a better guess at the encoding, you should
    set ``r.encoding`` appropriately before accessing this property.
    &#34;&#34;&#34;

    # Try charset from content-type
    content = None
    encoding = self.encoding

    if not self.content:
        return str(&#39;&#39;)

    # Fallback to auto-detected encoding.
    if self.encoding is None:
        encoding = self.apparent_encoding

    # Decode unicode from given encoding.
    try:
        content = str(self.content, encoding, errors=&#39;replace&#39;)
    except (LookupError, TypeError):
        # A LookupError is raised if the encoding was not found which could
        # indicate a misspelling or similar mistake.
        #
        # A TypeError can be raised if encoding is None
        #
        # So we try blindly encoding.
        content = str(self.content, errors=&#39;replace&#39;)

    return content</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tabellen.tasks.Response.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Releases the connection back to the pool. Once this method has been
called the underlying <code>raw</code> object must not be accessed again.</p>
<p><em>Note: Should not normally need to be called explicitly.</em></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Releases the connection back to the pool. Once this method has been
    called the underlying ``raw`` object must not be accessed again.

    *Note: Should not normally need to be called explicitly.*
    &#34;&#34;&#34;
    if not self._content_consumed:
        self.raw.close()

    release_conn = getattr(self.raw, &#39;release_conn&#39;, None)
    if release_conn is not None:
        release_conn()</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.iter_content"><code class="name flex">
<span>def <span class="ident">iter_content</span></span>(<span>self, chunk_size=1, decode_unicode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterates over the response data.
When stream=True is set on the
request, this avoids reading the content at once into memory for
large responses.
The chunk size is the number of bytes it should
read into memory.
This is not necessarily the length of each item
returned as decoding can take place.</p>
<p>chunk_size must be of type int or None. A value of None will
function differently depending on the value of <code>stream</code>.
stream=True will read data as it arrives in whatever size the
chunks are received. If stream=False, data is returned as
a single chunk.</p>
<p>If decode_unicode is True, content will be decoded using the best
available encoding based on the response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_content(self, chunk_size=1, decode_unicode=False):
    &#34;&#34;&#34;Iterates over the response data.  When stream=True is set on the
    request, this avoids reading the content at once into memory for
    large responses.  The chunk size is the number of bytes it should
    read into memory.  This is not necessarily the length of each item
    returned as decoding can take place.

    chunk_size must be of type int or None. A value of None will
    function differently depending on the value of `stream`.
    stream=True will read data as it arrives in whatever size the
    chunks are received. If stream=False, data is returned as
    a single chunk.

    If decode_unicode is True, content will be decoded using the best
    available encoding based on the response.
    &#34;&#34;&#34;

    def generate():
        # Special case for urllib3.
        if hasattr(self.raw, &#39;stream&#39;):
            try:
                for chunk in self.raw.stream(chunk_size, decode_content=True):
                    yield chunk
            except ProtocolError as e:
                raise ChunkedEncodingError(e)
            except DecodeError as e:
                raise ContentDecodingError(e)
            except ReadTimeoutError as e:
                raise ConnectionError(e)
        else:
            # Standard file-like object.
            while True:
                chunk = self.raw.read(chunk_size)
                if not chunk:
                    break
                yield chunk

        self._content_consumed = True

    if self._content_consumed and isinstance(self._content, bool):
        raise StreamConsumedError()
    elif chunk_size is not None and not isinstance(chunk_size, int):
        raise TypeError(&#34;chunk_size must be an int, it is instead a %s.&#34; % type(chunk_size))
    # simulate reading small chunks of the content
    reused_chunks = iter_slices(self._content, chunk_size)

    stream_chunks = generate()

    chunks = reused_chunks if self._content_consumed else stream_chunks

    if decode_unicode:
        chunks = stream_decode_response_unicode(chunks, self)

    return chunks</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.iter_lines"><code class="name flex">
<span>def <span class="ident">iter_lines</span></span>(<span>self, chunk_size=512, decode_unicode=False, delimiter=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterates over the response data, one line at a time.
When
stream=True is set on the request, this avoids reading the
content at once into memory for large responses.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This method is not reentrant safe.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):
    &#34;&#34;&#34;Iterates over the response data, one line at a time.  When
    stream=True is set on the request, this avoids reading the
    content at once into memory for large responses.

    .. note:: This method is not reentrant safe.
    &#34;&#34;&#34;

    pending = None

    for chunk in self.iter_content(chunk_size=chunk_size, decode_unicode=decode_unicode):

        if pending is not None:
            chunk = pending + chunk

        if delimiter:
            lines = chunk.split(delimiter)
        else:
            lines = chunk.splitlines()

        if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:
            pending = lines.pop()
        else:
            pending = None

        for line in lines:
            yield line

    if pending is not None:
        yield pending</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the json-encoded content of a response, if any.</p>
<p>:param **kwargs: Optional arguments that <code>json.loads</code> takes.
:raises ValueError: If the response body does not contain valid json.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self, **kwargs):
    r&#34;&#34;&#34;Returns the json-encoded content of a response, if any.

    :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
    :raises ValueError: If the response body does not contain valid json.
    &#34;&#34;&#34;

    if not self.encoding and self.content and len(self.content) &gt; 3:
        # No encoding set. JSON RFC 4627 section 3 states we should expect
        # UTF-8, -16 or -32. Detect which one to use; If the detection or
        # decoding fails, fall back to `self.text` (using chardet to make
        # a best guess).
        encoding = guess_json_utf(self.content)
        if encoding is not None:
            try:
                return complexjson.loads(
                    self.content.decode(encoding), **kwargs
                )
            except UnicodeDecodeError:
                # Wrong UTF codec detected; usually because it&#39;s not UTF-8
                # but some other 8-bit codec.  This is an RFC violation,
                # and the server didn&#39;t bother to tell us what codec *was*
                # used.
                pass
    return complexjson.loads(self.text, **kwargs)</code></pre>
</details>
</dd>
<dt id="tabellen.tasks.Response.raise_for_status"><code class="name flex">
<span>def <span class="ident">raise_for_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Raises :class:<code>HTTPError</code>, if one occurred.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raise_for_status(self):
    &#34;&#34;&#34;Raises :class:`HTTPError`, if one occurred.&#34;&#34;&#34;

    http_error_msg = &#39;&#39;
    if isinstance(self.reason, bytes):
        # We attempt to decode utf-8 first because some servers
        # choose to localize their reason strings. If the string
        # isn&#39;t utf-8, we fall back to iso-8859-1 for all other
        # encodings. (See PR #3538)
        try:
            reason = self.reason.decode(&#39;utf-8&#39;)
        except UnicodeDecodeError:
            reason = self.reason.decode(&#39;iso-8859-1&#39;)
    else:
        reason = self.reason

    if 400 &lt;= self.status_code &lt; 500:
        http_error_msg = u&#39;%s Client Error: %s for url: %s&#39; % (self.status_code, reason, self.url)

    elif 500 &lt;= self.status_code &lt; 600:
        http_error_msg = u&#39;%s Server Error: %s for url: %s&#39; % (self.status_code, reason, self.url)

    if http_error_msg:
        raise HTTPError(http_error_msg, response=self)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tabellen" href="index.html">tabellen</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tabellen.tasks.post_request" href="#tabellen.tasks.post_request">post_request</a></code></li>
<li><code><a title="tabellen.tasks.revoke_task" href="#tabellen.tasks.revoke_task">revoke_task</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tabellen.tasks.Response" href="#tabellen.tasks.Response">Response</a></code></h4>
<ul class="">
<li><code><a title="tabellen.tasks.Response.apparent_encoding" href="#tabellen.tasks.Response.apparent_encoding">apparent_encoding</a></code></li>
<li><code><a title="tabellen.tasks.Response.close" href="#tabellen.tasks.Response.close">close</a></code></li>
<li><code><a title="tabellen.tasks.Response.content" href="#tabellen.tasks.Response.content">content</a></code></li>
<li><code><a title="tabellen.tasks.Response.is_permanent_redirect" href="#tabellen.tasks.Response.is_permanent_redirect">is_permanent_redirect</a></code></li>
<li><code><a title="tabellen.tasks.Response.is_redirect" href="#tabellen.tasks.Response.is_redirect">is_redirect</a></code></li>
<li><code><a title="tabellen.tasks.Response.iter_content" href="#tabellen.tasks.Response.iter_content">iter_content</a></code></li>
<li><code><a title="tabellen.tasks.Response.iter_lines" href="#tabellen.tasks.Response.iter_lines">iter_lines</a></code></li>
<li><code><a title="tabellen.tasks.Response.json" href="#tabellen.tasks.Response.json">json</a></code></li>
<li><code><a title="tabellen.tasks.Response.links" href="#tabellen.tasks.Response.links">links</a></code></li>
<li><code><a title="tabellen.tasks.Response.next" href="#tabellen.tasks.Response.next">next</a></code></li>
<li><code><a title="tabellen.tasks.Response.ok" href="#tabellen.tasks.Response.ok">ok</a></code></li>
<li><code><a title="tabellen.tasks.Response.raise_for_status" href="#tabellen.tasks.Response.raise_for_status">raise_for_status</a></code></li>
<li><code><a title="tabellen.tasks.Response.text" href="#tabellen.tasks.Response.text">text</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>